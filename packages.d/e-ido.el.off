(initsplit-this-file bos (| "ido-" "smex-"))

;; (req-package ivy
;;   :diminish (ivy-mode "")
;;   :config
;;   (setq ivy-format-function 'ivy-format-function-line
;;         ivy-use-virtual-buffers t)
;;   (ivy-mode)
;;   (require 'ivy-buffer-extend))


;; (req-package counsel
;;   :demand
;;   :bind (("<menu>" . counsel-imenu))
;;   :diminish (counsel-mode "")
;;   :config
;;   (setq counsel-find-file-ignore-regexp "\\`\\.")
;;   (counsel-mode)
;;   (defadvice counsel-yank-pop (around sometimes-yank-pop (arg))
;;     (interactive "p")
;;     (if (not (memq last-command '(yank)))
;;         ad-do-it
;;       (call-interactively 'yank-pop)))
;;   (ad-activate 'counsel-yank-pop))

;; (el-get-bundle larkery/ido-match-modes.el)

                               (= (length ido-text) 0))))

      (dolist (item items)
        (setq name (ido-name item)
              mi nil
              me nil)
        (setq nlen (length name))
        (when (and (or non-prefix-dot
                       (= ido-text0 (aref name 0) ?.)
                       (and (= ?. ido-text0)
                            (/= (aref name 0) ?.)))
                   (setq mi (string-match re name)))
          (setq me (match-end 0))

          (cond
           ((= count nlen)
            (setq exact-matches (cons item exact-matches)
                  my-ido-common-completion ""
                  common-completion-length 0)) ;; clear the completion since this is full-length
           ((zerop mi)
            (setq prefix-matches (cons item prefix-matches)))
           (t (setq matches (cons item matches))))

          (if my-ido-common-completion
              ;; if the ccl is already zero, we don't bother
              (unless (zerop common-completion-length)
                ;; if the current match goes to the end
                ;; we know that there can be no more completion
                (if (= me nlen)
                    (setq my-ido-common-completion ""
                          common-completion-length 0)
                  ;; otherwise, scan the rest of item
                  ;; until either we get to the end
                  ;; or a mismatch
                  (setq common-completion-length
                          (loop for i from 0 to (min (- common-completion-length 1)
                                                     (- nlen me 1))

                                until (/= (aref my-ido-common-completion i)
                                          (aref name (+ i me)))

                                finally return i))
                  ))
            ;; this is the case where it's the first item
            ;; so the completion is all the rest.
            (progn (setq my-ido-common-completion (substring name me))
                   (setq common-completion-length (length my-ido-common-completion)))
            )))

      ;; set the completion string
      ;; for some reason that has the input string
      ;; added to the start.
      (setq my-ido-common-completion
            (if my-ido-common-completion
                (concat ido-text (substring my-ido-common-completion 0 common-completion-length))
              ido-text))

      (setq matches (nconc exact-matches prefix-matches matches))
      (setq my-last-ido-regexp re)
      (delete-consecutive-dups matches t)))


  (advice-add 'ido-set-matches-1 :override #'my-ido-set-matches-1)

  (add-hook 'ido-setup-hook
            (lambda () (define-key ido-completion-map " " #'self-insert-command))))

(req-package ido-exit-target)

(req-package ido-grid
  :config
  (setq ido-grid-indent 0)
  (ido-grid-enable)

  (defun my-ido-grid-re-hack (o &rest args)
    (let ((ido-enable-regexp t)
          (ido-text my-last-ido-regexp))
      (apply o args)))

  (advice-add 'ido-grid--grid-ensure-visible :around #'my-ido-grid-re-hack))

(req-package ido-ubiquitous
  :config
  (ido-ubiquitous-mode)
  (ido-everywhere 1))

(req-package ido-at-point
  :config
  (ido-at-point-mode 1))

(req-package ido-describe-prefix-bindings
  :demand
  :bind ("M-X" . ido-describe-mode-bindings)
  :config
  (require 's)
  (ido-describe-prefix-bindings-mode 1))

(req-package smex
  :commands smex
  :require (ido ido-ubiquitous)
  :bind (("M-x" . smex))
  :config
  (setq smex-save-file (concat (my-state-dir "") "smex")
        smex-flex-matching nil)

  (defun h/advise-smex-bindings ()
    (define-key ido-completion-map (kbd "<tab>") 'ido-complete))

  (advice-add 'smex-prepare-ido-bindings :after #'h/advise-smex-bindings))
(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(ido-grid-rows 6)
 '(ido-grid-special-commands
   (quote
    ((describe-prefix-bindings 8 1 nil 0)
     (cr-recentf 10 1 nil 0))))
 '(ido-grid-start-small t))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(ido-grid-match-1 ((t (:inherit match :slant italic))))
 '(ido-grid-match-2 ((t (:inherit ido-grid-match-1))))
 '(ido-grid-match-3 ((t (:inherit ido-grid-match-1)))))
